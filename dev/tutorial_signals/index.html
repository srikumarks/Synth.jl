<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Signal Processes · Synth Docs</title><meta name="title" content="Signal Processes · Synth Docs"/><meta property="og:title" content="Signal Processes · Synth Docs"/><meta property="twitter:title" content="Signal Processes · Synth Docs"/><meta name="description" content="Documentation for Synth Docs."/><meta property="og:description" content="Documentation for Synth Docs."/><meta property="twitter:description" content="Documentation for Synth Docs."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Synth Docs</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">Synth.jl Documentation</a></li><li><a class="tocitem" href="../start/">Getting started</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_basic/">Basic tutorial</a></li><li><a class="tocitem" href="../tutorial_synth/">Sampling synthesis</a></li><li><a class="tocitem" href="../tutorial_gens/">Musical processes</a></li><li class="is-active"><a class="tocitem" href>Signal Processes</a><ul class="internal"><li><a class="tocitem" href="#The-delay-line"><span>The delay line</span></a></li><li><a class="tocitem" href="#Creating-your-own-signal-process"><span>Creating your own signal process</span></a></li><li><a class="tocitem" href="#Performance-and-the-type-system"><span>Performance and the type system</span></a></li></ul></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../basic/">Basic signals</a></li><li><a class="tocitem" href="../stereo/">Stereo signals</a></li><li><a class="tocitem" href="../gen/">Generators</a></li><li><a class="tocitem" href="../music/">For music</a></li><li><a class="tocitem" href="../render/">Rendering</a></li><li><a class="tocitem" href="../rt/">Realtime playback</a></li><li><a class="tocitem" href="../filters/">Filters</a></li><li><a class="tocitem" href="../fx/">Effects</a></li><li><a class="tocitem" href="../tx/">Transformers</a></li><li><a class="tocitem" href="../wt/">Wavetable synthesis</a></li><li><a class="tocitem" href="../gran/">Granular synthesis</a></li><li><a class="tocitem" href="../utils/">Utilities</a></li></ul></li><li><span class="tocitem">Other</span><ul><li><a class="tocitem" href="../design/">Design</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Signal Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Signal Processes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/srikumarks/Synth.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/srikumarks/Synth.jl/blob/main/docs/src/tutorial_signals.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Signal-Processes"><a class="docs-heading-anchor" href="#Signal-Processes">Signal Processes</a><a id="Signal-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Signal-Processes" title="Permalink"></a></h1><p>Here we look at how to code up your own &quot;signal processes&quot;. Note that we&#39;re not using the phrase &quot;signal processors&quot; but &quot;signal processes&quot; instead, to suggest processes that produce a sequence of sample values that vary over time while possibly updating internal state along the way. So each sample output is dependent on the previous state.</p><p>Some processes may be explicitly dependent on the time value, but we&#39;re in general interested in &quot;time invariant processes&quot; – i.e. where the evolution of a process does not depend on when in time it is played. While this seems like a restriction, it is a very meaningful restriction when it comes to music and sound processing where &quot;linear time invariant filters&quot; are a common way to alter the spectrum of sound.</p><h2 id="The-delay-line"><a class="docs-heading-anchor" href="#The-delay-line">The delay line</a><a id="The-delay-line-1"></a><a class="docs-heading-anchor-permalink" href="#The-delay-line" title="Permalink"></a></h2><p>To get an intro to how signals work in <code>Synth.jl</code>, it is instructive to look at how the delay line is designed. It is common in synthesizers to model a delay line with a fixed number of tap points which may vary over time. By contrast, in <code>Synth.jl</code>, the number of tap points of the delay line is not fixed and the tap points themselves can vary at audio rate. Here is how you&#39;d use a delay line in <code>Synth.jl</code>.</p><pre><code class="language-julia hljs">s = #... some signal
maxdelay = 1.0 # in seconds
d = delay(s, maxdelay)
tapsig = sinosc(0.25, 100.0)
tap1 = tap(d, tapsig + 0.25)
tap2 = tap(d, tapsig + 0.3)
play(tap1 * tap2, 2.0)</code></pre><p>As you see, you create a <a href="../filters/#Synth.delay"><code>delay</code></a>, which is itself a pass-through signal which supports fanout. If you play the delayed signal directly, you won&#39;t notice any delay because that&#39;s how it is configured. To tap into the delay line, you create <a href="../filters/#Synth.tap"><code>tap</code></a> signals with a possibly time-varying tap point. These tap signals can then be used like ordinary signals in any further compositions.</p><p>This works because while the delay-line continuously updates based on the signal it is getting fed, the tap point&#39;s job is to simply look into the delay line and pick an interpolated value. In doing that, the tap points will trigger the delay line&#39;s processing function, but multiple tap points won&#39;t trigger it multiple times because the delay line supports intrinsic fanout.</p><h2 id="Creating-your-own-signal-process"><a class="docs-heading-anchor" href="#Creating-your-own-signal-process">Creating your own signal process</a><a id="Creating-your-own-signal-process-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-your-own-signal-process" title="Permalink"></a></h2><p>To do this for your own signal, you need to do the following –</p><ol><li>Create a concrete mutable subtype (say <code>MySig</code>) of <code>Signal</code> or <code>SignalWithFanout</code>.</li><li>Implement <code>done(::MySig, t, dt) :: Bool</code></li><li>Implement <code>value(::MySig, t, dt) :: Float32</code>.</li><li>Make an easy to use constructor function for your signal process.</li></ol><p>The <code>done</code> method is expected to return <code>true</code> when the signal process is considered &quot;finished&quot;. The <code>done</code> method is generally expected to be called once per audio frame (like 64 samples), but in some cases may be called more often. </p><p>The <code>value</code> method is expected to compute the next sample value and return it. It is expected to return a valid value (typically <code>0.0f0</code> by convention) even if the signal is considered &quot;finished&quot; when the value method is called. i.e., the design of the implementation of the <code>value</code> method should be such that it is permissible for it to be called for a short while after the signal is considered &quot;finished&quot;. The <code>value</code> method will in general update the state along the way as well.</p><p>As an example, here is a four-sample FIR filter.</p><pre><code class="language-julia hljs">using Synth : Signal

mutable struct P4Filter{S &lt;: Signal} &lt;: Signal
    sig :: S
    a0 :: Float32
    a1 :: Float32
    a2 :: Float32
    a3 :: Float32
    x0 :: Float32
    x1 :: Float32
    x2 :: Float32
    x3 :: Float32
end

done(s:: P4Filter, t, dt) = done(s.sig, t, dt)

function value(s::P4Filter{S}, t, dt) where {S &lt;: Signal}
    # Compute the next input sample value.
    # If `s` happens to be a `SignalWithFanout`, then the
    # main body of the value call will only get evaluated
    # once for a given time `t`. Here, `dt` is generally
    # 1/SR. So for the default sample rate, this will be 1/48000.
    v = value(s.sig, t, dt)
    
    # Shift the sample memory by one sample.
    s.x3 = s.x2
    s.x2 = s.x1
    s.x1 = s.x0
    s.x0 = v

    # Compute the output as a linear sum of the input sample values
    # delayed by a few samples.
    s.a0 * s.x0 + s.a1 * s.x1 + s.a2 * s.x2 + s.a3 * s.x3
end

# Make a convenient constructor. Note that any time-evolving state
# in the structure should, if possible, not be exposed as constructor arguments.
# Doing that will ensure that the signal process always starts in a known state.
# In some situations, you might wish to expose the starting state, but they
# are likely exceptions as usually they end up cluttering the interface.
function p4filter(s :: S, a0 :: Real, a1 :: Real, a2 :: Real, a3 :: Real) where {S &lt;: Signal}
    MySig(s, Float32(a0), Float32(a1), Float32(a2), Float32(a3), 0.0f0, 0.0f0, 0.0f0, 0.0f0)
end</code></pre><p>With that much, you can already use your signal process on an equal footing with all the other operators in the package.</p><pre><code class="language-julia hljs">s = phasor(300)
sf = p4filter(s, 0.2, 0.3, 0.3, 0.2) # Simple low pass
play(sf, 2.0)</code></pre><p>If you want to support fanout intrinsically (as opposed to via <a href="../basic/#Synth.fanout"><code>fanout</code></a>),  you should use <code>SignalWithFanout</code> as the abstract type and ensure that the computation done within value isn&#39;t repeated if asked repeatedly for the same time. You may assume that time increases monotonically. </p><h2 id="Performance-and-the-type-system"><a class="docs-heading-anchor" href="#Performance-and-the-type-system">Performance and the type system</a><a id="Performance-and-the-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-and-the-type-system" title="Permalink"></a></h2><p>The way we defined <code>P4Filter</code> above, we introduced a signal type parameter that is made concrete at instantiation time. This means we aren&#39;t storing a dynamic signal value when constructing a <code>P4Filter</code>, but we know exactly what signal we&#39;re filtering using <code>P4Filter</code>. This is excellent for performance because the types are all know when compiling the <code>value</code> call on the <code>P4Filter</code> value and can be  optimized by Julia&#39;s just-ahead-of-time type specializing compiler.</p><p>Most signals defined in this package are designed similarly, so when you construct compound signals, you&#39;ll often find the types that get printed out for them to be very lengthy in printed form. i.e. The type of the signal carries all the information about the structure of the signal flow graph that is  necessary to optimize the computation of its values. </p><p>Of course, for certain kinds of signals, this isn&#39;t possible. In particular, for the <a href="../rt/#Synth.bus"><code>bus</code></a>, to which signals that are not known ahead of time can be scheduled. In this case, the first call to <code>value(::Bus,t,dt)</code> will  do a dynamic dispatch (which is also reasonably fast in Julia), but often that dispatched function itself will have the entire call tree statically determined and will likely have a precompiled version available for use, thus speeding up the compilation.</p><p>In all this, it is <em>possible</em> that occasionally the compilation step takes a wee bit of time that may cause an audio stutter, but that has been somewhat rare in experience and can be mitigated through appropriate precompiled functions.</p><p>In the design of the constructor function, we generally make the arguments be as general as possible and do the necessary type conversions to concrete types within the function when building up the <code>struct</code>. That way, the constructor functions end up being easy to use without being to strict about <code>Float32</code>  versus <code>Float64</code> versus <code>Int</code>, for example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_gens/">« Musical processes</a><a class="docs-footer-nextpage" href="../basic/">Basic signals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 19 October 2025 12:01">Sunday 19 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
